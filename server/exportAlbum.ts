import * as db from "./db";
import { getPlatformAdapter } from "./adapters";

export interface ExportedAlbum {
  album: {
    title: string;
    theme: string;
    description: string;
    platform: string;
    coverUrl?: string;
  };
  tracks: Array<{
    index: number;
    title: string;
    prompt: string;
    lyrics: string;
    structure: string;
    tempoBpm: string;
    key: string;
    moodTags: string[];
    productionNotes: string;
    artUrl?: string;
  }>;
  metadata: {
    exportedAt: string;
    version: string;
  };
}

/**
 * Generate README content for album export
 */
function generateReadme(album: any, platform: string): string {
  const adapter = getPlatformAdapter(platform);
  
  return `# ${album.title}

## Album Information
- **Theme**: ${album.theme}
- **Description**: ${album.description}
- **Platform**: ${adapter.displayName}
- **Tracks**: ${album.tracks.length}

## How to Use

### On ${adapter.displayName}

${adapter.getExportInstructions()}

### Files Included

- \`album.json\` - Complete album data with all prompts and lyrics
- \`cover.jpg\` - Album cover artwork (if available)
- \`tracks/\` - Individual track artwork (if available)
- \`README.md\` - This file

## Track List

${album.tracks.map((t: any, i: number) => `${i + 1}. **${t.title}**
   - Tempo: ${t.tempoBpm}
   - Key: ${t.key}
   - Mood: ${t.moodTags?.join(", ") || "N/A"}`).join("\n\n")}

## Platform Constraints

${Object.entries(adapter.constraints()).map(([key, constraint]: [string, any]) => 
  `- **${constraint.name}**: ${constraint.maxChars ? `${constraint.maxChars} characters max` : "No limit"}`
).join("\n")}

## Best Practices

${adapter.bestPractices().map((p, i) => `${i + 1}. ${p}`).join("\n")}

---

Generated by AI Album Creator
${new Date().toISOString()}
`;
}

/**
 * Export album as downloadable bundle
 */
export async function exportAlbumBundle(albumId: number): Promise<{
  json: ExportedAlbum;
  readme: string;
  coverUrl?: string;
  trackArtUrls: string[];
}> {
  const album = await db.getAlbumById(albumId);
  if (!album) {
    throw new Error("Album not found");
  }

  const tracks = await db.getAlbumTracks(albumId);
  const tracksWithAssets = await Promise.all(
    tracks.map(async (track) => {
      const assets = await db.getTrackAssets(track.id);
      
      const promptAsset = assets.find(a => a.type === "prompt");
      const lyricsAsset = assets.find(a => a.type === "lyrics");
      const structureAsset = assets.find(a => a.type === "structure");
      const productionAsset = assets.find(a => a.type === "production_notes");
      const artAsset = assets.find(a => a.type === "art_url");
      
      return {
        index: track.index,
        title: track.title,
        prompt: promptAsset?.content || "",
        lyrics: lyricsAsset?.content || "",
        structure: structureAsset?.content || "",
        tempoBpm: track.tempoBpm || "",
        key: track.key || "",
        moodTags: JSON.parse(track.moodTags || "[]"),
        productionNotes: productionAsset?.content || "",
        artUrl: artAsset?.content
      };
    })
  );

  const exportData: ExportedAlbum = {
    album: {
      title: album.title,
      theme: album.theme,
      description: album.description || "",
      platform: album.platform,
      coverUrl: album.coverUrl || undefined
    },
    tracks: tracksWithAssets,
    metadata: {
      exportedAt: new Date().toISOString(),
      version: "1.0"
    }
  };

  const readme = generateReadme({
    ...album,
    tracks: tracksWithAssets
  }, album.platform);

  const trackArtUrls = tracksWithAssets
    .map(t => t.artUrl)
    .filter((url): url is string => !!url);

  return {
    json: exportData,
    readme,
    coverUrl: album.coverUrl || undefined,
    trackArtUrls
  };
}
